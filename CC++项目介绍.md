

## 服务器类

### HTTP**服务器功能**

| 功能层次 | 功能名称     | 详细设计                                                     |
| :------: | ------------ | ------------------------------------------------------------ |
| 核心功能 | 服务器功能   | 1、监听端口<br />2、接受客户端连接请求<br />3、处理请求并发送响应 |
|          | 并发处理     | 1、多线程<br />2、异步并发                                   |
|          | 协议支持     | 相对应的http版本                                             |
| 辅助功能 | 缓存         | 静态页面缓存                                                 |
|          | 压缩算法支持 | 支持常见的压缩算法gzip                                       |
|          | 负载均衡     | 负载均衡相关策略                                             |
|          | 日志管理     | 1、日志自动分片<br />2、日志自动压缩                         |
|          | 扩展协议支持 | 支持SSL算法                                                  |

------



### 1、C++11编写的Web服务器

本项目为C++11编写的Web服务器，解析了get、head请求，可处理静态资源，支持HTTP长连接，支持管线化请求，并实现了异步日志，记录服务器运行状态。

代码链接如下：[c++11 webServer](https://github.com/linyacool/WebServer)

### 2、oatpp web框架

Oat++ is a modern Web Framework for C++. It's fully loaded and contains all necessary components for effective production level development. It's also light and has a small memory footprint.

代码链接如下：[oatpp](https://github.com/oatpp/oatpp)

#### 注：web框架和web服务器的区别？

答：web服务器（web server）的主要作用是，接收客户端请求，而web框架（web framework）则是处理web服务器收到的请求，并生成HTML内容，将生成的内容传递给web服务器，再由web服务器返回给客户端。

服务器和客户端之间的连接靠web服务器来维持，web服务器接收到请求后，将请求以及相关的参数传递给web框架，由框架负责生成内容，并将生成的内容传递给web服务器。所以web服务器的职责是接受并返回请求，web服务器的职责是内容生成。

web服务器封装的是socket，web框架封装的是response和request

![img](https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210630130947.png)

### 3、TinyHttpd

代码链接如下：[tinyhttpd](https://github.com/EZLippi/Tinyhttpd)

### 4、TinyWebServer

代码链接如下：[TinyWebServer](https://github.com/qinguoyi/TinyWebServer)

Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.

### 5、WebBench

Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。

代码链接如下：[WebBench](https://github.com/EZLippi/WebBench)

### 6、A C++ Lightweight Web Server

这是一个轻量级的Web服务器，目前支持GET、HEAD方法处理静态资源。并发模型选择: 单进程＋Reactor+非阻塞方式运行。

代码链接如下：[webserver](https://github.com/imarvinle/WebServer)

### 7、candy webSever

Linux C++基于Epoll从零开始实现HTTP服务器

代码链接如下：[candy](https://github.com/Jsiyong/candy)

项目后端使用C++开发语言，以Linux为开发环境，基于epoll边缘非阻塞模型，从http协议的解析，到表单multipart/form-data协议的解析，再到JSON协议的解析，再到C++对象的序列化，一步一个脚印实现一个http服务器。实现的功能有文件的上传、下载、删除、改名等。

前端采用vue框架，为了简单，没有使用node.js，使用httpVueLoader来解析vue文件，因为前端不是重点。

------



### 8、Monkey

**B站轻量级http[服务器](https://www.bilibili.com/video/BV1F4411k7n7?p=10&spm_id_from=pageDriver)**

- **性能要求**

  - 响应时间
    - 客户从发出请求到受到响应的时间
    - 响应时间直接关系到用户的感受
  - 吞吐量
    - 单位时间内系统处理的客户请求数（常用单位TPS）
    - 体现软件系统的承载能力
  - 并发用户数量
    - 系统同时处理请求的数量
    - 最大用户容量、同时在线用户数
  - 服务时间
    - 对外持续服务时间
  - 故障率
    - 容许最长故障时间
    - 错误频率

- **Monkey的模块规划**

  |   模块名称   |     源文件      |                           功能说明                           |
  | :----------: | :-------------: | :----------------------------------------------------------: |
  |   连接管理   | mk_connection.c |                  链接读/写，关闭，超时处理                   |
  |   请求管理   |  mk_request.c   | 请求建立与释放，request列表管理，<br />request解析和处理，会话管理 |
  |  epoll模块   |   mk_epoll.c    |               epoll创建，注册，删除，事件监听                |
  |   HTTP模块   |    mk_http.c    |                         HTTP协议处理                         |
  | 线程管理模块 | mk_scheduler.c  |                           线程管理                           |

- 总结

  这个项目是用c语言写的，偏工业级别的代码风格，非常严谨，学习可以，目前个人能力无法写出来

------

### 9、FTP文件传输服务器

B站的一个基于c语言的项目

[网站网址如下](https://www.bilibili.com/video/BV1tX4y1V7cd/?spm_id_from=333.788.recommend_more_video.0)

[另外已将项目上传到码云](https://gitee.com/issable/simple_-ftp_-by_-c)

- **FTP服务器流程**

  - 下载流程

    1. 客户端请求下载文件——把文件名发送给服务器
  2. 服务器端会收到客户端发送的文件名——客户端根据文件名找到相对应文件地址
  3. 服务器把文件大小发送给客户端
    4. 客户端收到文件大小的数据之后——客户端开辟内存，完成后告诉服务器可以开始接受文件
  5. 服务器收到开始发送的指令后，发送文件数据
    6. 客户端接收数据，接收完成后告诉服务器
  7. 服务器接收到“下载完成”消息后，关闭连接 
  
- **实现细节**

  - 服务器端

    服务器端封装了一个struct，包含枚举类型，一个union，union里面有两个结构体（fileInfor结构体包含文件名和大小，packert包含要发送的数据内容和每次发送包的大小。），一个传递文件信息，一个传送具体文件数据（分片发送）

    服务器端收到服务端传来的消息时候，把消息封装成一个struct，取出ID和枚举值对比，执行相对应的函数。

    服务器端主要由两个函数，读取文件大小发送给客户端，让客户端开辟响应存储空间
  
    服务器端实现文件的分片发送
    
  - 客户端
  
    客户端主要有以下几个函数构成，重传函数，准备内存函数和写文件函数
  
    当收到服务器端关于文件大小后就可以申请内存，申请成功之后继续给服务器端发消息，告诉服务器端可以传数据。
  
  - 若发送数据超过结构体packet中定义的包大小，则进行分片发送。
  
    如何分片？若要下载大文件，则必须把每一次服务端发送的包给填满，之后将包不断的发送给客户端，客户端收到这些包后会在本地开辟的内存中不断地接收这些包，直到组成完整的文件数据。实现中要设置一个标志位(start)，来确定文件内容的索引，索引之前的表示已经发送。

------

### 10、网络聊天室实现

[B站视频链接](https://www.bilibili.com/video/BV1mt411Q7Hf/?spm_id_from=333.788.recommend_more_video.0)

- **整体框架**

  >通过tcp框架将客户端和服务端之间建立连接

  | 服务器                                       | 客户端                    |
  | :------------------------------------------- | :------------------------ |
  | 1、请求通信版本                              | 1、请求通信版本           |
  | 2、创建socket套接字，句柄                    | 2、创建socket套接字，句柄 |
  | 3、创建协议地址族                            | 3、确定服务器端协议地址族 |
  | 4、绑定<br/>将套接字和具体IP地址和端口号绑定 | 4、链接到服务器端         |
  | 5、监听                                      | 5、通过套接字通信         |
  | 6、接受客户端链接请求                        | 6、关闭链接               |
  | 7、通过套接字通信                            |                           |
  | 8、关闭链接                                  |                           |


- **实现多客户端（多进程并发模型）**	

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210723102146.png" alt="image-20210723102109623" style="zoom: 50%;" />

  书p173

  此实现分为三个阶段：

    		1. 服务器端（父进程）通过调用accept函数受理连接请求

    2. 父进程将获取的套接字文件描述符传递给子进程。没有别的传递方法，因为子进程会复制父进程拥有的所有资源，所以自然而然就拥有了套接字文件描述符。

       > 调用fork函数后，子进程会复制父进程的所有资源，但有一个例外的就是套接字。套接字是不能复制的，因为套接字属于操作系统管理。但是子进程可以拥有相应套接字的文件描述符。因此会出现问题：一个套接字会存在两个文件描述符，只有两个文件描述符都被销毁，才能关闭套接字。
       >
       > 因此为了方便，我们需要让一个文件描述符指向一个套接字。
       >
       > 首先要明白，有客户端链接过来，我可以用父进程来处理。但是，当有多个客户端的时候，必须让子进程处理每一个客户端，因为父进程还维护着服务端套接字。所以我们要关闭父进程指向客户端的文件描述符，子进程指向服务端的文件描述符。这样的话，父进程只需要保留指向服务端套接字的文件描述符，客户端只需要保存指向客户端的文件描述符就行。

          		3. 子进程利用传来的文件描述符提供服务
          		4. 客服端也可以是用多进程的思想（p178）。在客户端分割tcp的I/O程序。之前代码是想服务器端传输数据并等待服务端的回复，这样是无条件等待的，只有收到服务端的数据后客户端才会传递下一批数据。现在创建多个进程，分割数据的收发过程父进程负责接收数据，同时子进程负责发送数据。分割后不同进程分别负责输入和输出，这样做可以不用考虑接收数据的情况，可以连续发送数据，提高同一时间内数据传输量。

- 信号技术处理僵尸进程

  由于子进程终止的不可预测性，调用wait处理子进程会一直阻塞，调用waitpid处理子进程会一直轮询。。

  由于识别子进程终止的实体是操作系统，因此可以利用操作系统告诉父进程子进程的消亡情况。由此引入信号处理机制，此时特定时间发生时由操作系统向进程发送消息。

  使用signal函数，传入SIGCHILD参数，表示子进程终止，则调用相关的函数（很少用）

  使用sigaction函数，因为这个函数在所有操作系统中都相同。第一个参数传递SIGCHILD，第二个参数是信号处理函数的信息。第三个参数一般为0



------



## STL类

### 1、SGI-STL

剖析stl

代码链接如下：[SGI-STl](https://github.com/steveLauwh/SGI-STL)

### 2、MyTinySTL

基于 C++11 的 tinySTL

代码链接如下：[mytinystl](https://github.com/Alinshans/MyTinySTL)

## 其他类

### 1、dbg-macro，日志项目

代码链接如下：[dbg-macro](https://github.com/sharkdp/dbg-macro)

### 2、从零开始的 JSON 库教程

[json-tutorial](https://gitee.com/issable/json-tutorial)

- **什么是json**

  json是一个用于数据交换的文本格式，是一个数据格式，可以被任何编程语言所解析。现在跟接送相同功能的还有XML，YAML，但是json语法相对简单易懂。对于json格式来说可以概括为6种类型

  ![image-20210719195927479](https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210719200001.png)

null和boolean很好理解，number用一般的浮点数表示方式，string用“”双引号包括，array用[]包括，对象用{}包括。

- **json语法子集**

- **环境相关**

  使用c和c++开发，c是用linux写的，编译工具用的是CMake。c++用的是vs写

- **开始时的设计**

  用枚举实现了两个个状态向量机，根据枚举状态机来对每一种数据类型进行操作，另一个状态机的作用是解析完成后返回相应的状态值，比如说是满足json语法格式返回ok，只有空白返回expect_value,若不是null，false或者true返回invalid_value。在c中感觉用enum会多一点，便与每个函数之间的交互。

- **解析器**

  - 准备工作。首先为了保证数据和结构的整洁吧，将数据封装到一个结构体中。判断格式也非常简单，首先要跳过空白，只检测当前的第一个字符，根据第一个字符调用相对应的解析函数。

    检测也是有技巧的，即 第一个字符是n就是null，t就是true，”就是string，[就是数组，{就是对象等等。然后我们根据相应的语法来写函数。

  - 解析数字类型。数字一般都是十进制，由四部分组成，负数、整数、小数和指数，但是正好是不合法的。他有几个重点吧比如说①0开始，只能是单个0。比如0123不合法②如果第一个数字是1-9的话可以加任意的数字。③如果是浮点数的话小数点后面可以跟0-9任意数字。

    因为简单起见，选择double类型来存储数字。对于数字的解析直接采用c库函数strtod()，将字符串转换成double。数字过大处理是将解析出来的double值和HUGE_VAL比较，看是否溢出。error设置为ERANGE。
    
  - 字符串类型解析。字符串是双引号分割的，中间夹着零至多个字符。字符要分为转义和非转义字符，转义字符好像有9中，这个要查文档，记不太行了。比如\n换行符啥的。

    难点在于编程语言中字符串结尾会隐藏一个空字符 `\0`，但是json字符串允许含有空字符。由于一个值不可能同时是字符串或者数字，因此使用union节省空间。由于字符串的长度是不确定的，所以动态分配内存，把解析的结果放在一个临时的缓冲区，等这一个字符串解析完了给取出。但是缓冲区的大小无法预估，所以当时考虑用动态数组。但是动态数组每次解析字符串的时候都要重新构造，比较麻烦，因此后来我才用动态堆栈，每次解析json都可以使用相同堆栈。

    动态堆栈就需要用一个结构体封装。一个栈指针，堆栈初始大小和栈顶top(为了扩展不用指针表示)，因为我需要判断top+栈的现存size是否大于初始化的size大小，大于的话就1.5倍扩展栈，然后realloc重新分配内存。

    处理unicode。把Unicode编码使用utf8转换格式转储。c库函数没有处理Unicode的处理，因此只能自己写。感觉对Unicode和utf8有一定了解。

  - 解析数组。一个json数组可以包含零到和若干个元素。遇到‘[’ 就压入栈，遇到‘]‘就弹出。还是用字符串解析时的能自动扩展的堆栈作为缓冲区，能分配最紧凑的数组作为存储，感觉比较省内存。

  - 解析对象。和解析数组很相似，对象成员就是键值对，键必须为json的字符串，值可以使任何json值，中间用冒号隔开。要维护键值对有很多种数据结构可供选择，比如数组，平衡二叉树和哈希表，用动态数组实现。

- **单元测试**

  之前写代码出了调试之外，想看看测试结果都是把其中的步骤结果打印到输出控制台上，然后看看是否合乎预期。当代码多了之后，感觉这种办法效率就特别低下，然后我采用的是单元测试这种方法。
  
  一般来说，先写功能，然后加入该功能的测试。我这边用的是测试驱动开发TDD，先加入测试，然后运行测试，第一次肯定会失败因为没有添加任何功能。接着编写实现代码，再运行测试。接着重构代码，使之更加完善。

### 3、基于跳表的键值性存储引擎

- 项目概述

  - 用c++编写的一个键值对存储引擎，主要的数据结构是跳表。这个项目主要可以做到增山查改，同时还实现了展示数据，把数据保存在本地，以及读取文件中的键值对数据以及显示该数据库中数据的大小。

- 使用场景

  主要是存储key-value键值对的

- 跳表结构描述

  对于跳表的讲解可以参考这个：[跳表](https://www.bilibili.com/video/BV1tK4y1X7de/?spm_id_from=333.788.recommend_more_video.0)

  链表无法二分查找，我们想办法跳跃着来找。然后说一下数组，链表，二叉树，红黑树的优缺点。

  - 数组

    数组是连续的内存地址，cpu会把一段连续的缓存空间读入，因而读取比较快。数组访问某个元素的时候为O(1)的时间复杂度。查找我们就说二分查找，时间复杂度为O(logN)，插入和删除都是O(n)。数组寻址 [基地址+元素大小*k] 就能找到第k个元素的地址

  - 链表

    链表的节点是分散在堆空间中的，cpu的缓存帮不上什么忙，因此其寻址操作要做很多步。因此链表查找很慢，但是插入和删除简单。

  - 二叉树

    查找的时候一般为O(logN)，但是最坏为O(N)，因为当元素全部有序的时候看上去就像一个链表。

  - 红黑树

    红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。但是实现挺麻烦的感觉。

  我觉得跳表本质上就是可以实现二分查找的有序链表

  跳表是一种概率化随机化的数据存储方式，主要由两个特点：**有序和层次。**我觉得这是跳表最突出的特点。效率和红黑树媲美而且实现要比红黑树简单的多。

  有以下几部分组成：

  1. 表头和表尾。表头就是跳表的起点，表位是跳表的末尾，均不存储任何数据，这个和链表是一样的
  2. 节点类，代表某个节点的数据。有key和value以及所在的层数
  3. 跳表类。主要包含最大层数，当前层数，头指针（节点类类型），元素个数（方便查询。）

- 查找算法

  查找的话是从跳表最高层的头结点开始的。**每一层都有一个forward数组，这个数组存储的是当前层中的指向下一个节点的指针。**比如

  <img src="https://upload-images.jianshu.io/upload_images/19063731-e95c396e6e62bc87.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1142/format/webp" alt="img" style="zoom:50%;" />

  节点1就有三层，因此节点1又forward[0]-forward[2]每个索引中存放的指向下一个节点的指针不一样。因此当代码如图

  ```c++
  for (int i = _skip_list_level; i >= 0; i--) {
          while (current->forward[i] && current->forward[i]->get_key() < key) {
              current = current->forward[i];
          }
      }
   //reached level 0 and advance pointer to right node, which we search
   current = current->forward[0];
  ```

- 插入算法

  因为数据库为了保证多线程的安全性，因此在插入和删除中都加了锁。用的是c++11标准中新增加的一个头文件，主要用的就是lock和unlock。

  插入元素的同时要更新每一层的索引，每当我插入一个节点的时候，这个节点会随机生成一个random level，然后根据这个random level来更新相关层中节点的指向，每次更新0 - random level之间的索引信息。

  random level函数是这样写的：

  ```c++
  int SkipList<K, V>::get_random_level(){
      int k = 1;
      while (rand() % 2) {
          k++;
      }
      k = (k < _max_level) ? k : _max_level;
      return k;
  };
  ```

  插入之前要判断节点是否存在，这一步和查找其实差不多。然后不存在就不插入，返回1表示有

  如果随机生成的这个random level 的值大于当前的level，我们就是更新一个数组，把当前层和最高层之间的header放进去，然后当前层更新到最高层。

  插入的话就是老样子，新节点的next指向当前节点的next，当前节点的next指向新节点。

  插入新元素的时候，尽量让该元素有1/2的几率简历一级索引，1/4的几率建立二级索引。每次有新节点加入的时候，通过算法告诉我们最高加到底基层，

- 删除算法

  有了插入元素删除也好些，因为删除也要找到相关元素。这跟前面代码都差不多，删除的话要把每一层forward中存储的又相关节点信息的指针删除干净

- 数据落盘

  用到文件操作符ofstream和ifstream，这都是很常规的。

- 高度策略控制

  自己设置的最大高度

https://blog.csdn.net/silence1772/article/details/55005008)

